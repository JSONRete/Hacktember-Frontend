"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var cssColorUtils_exports = {};
__export(cssColorUtils_exports, {
  colorToSameTypeString: () => colorToSameTypeString,
  hexStringToRgbaColor: () => hexStringToRgbaColor,
  stringToHslaColor: () => stringToHslaColor,
  stringToSameTypeColor: () => stringToSameTypeColor
});
module.exports = __toCommonJS(cssColorUtils_exports);
var import_predicates = require("./predicates");
const CLEAN_HSLA_REGEX = /[hsla()]/g;
const CLEAN_RGBA_REGEX = /[rgba()]/g;
const stringToHslaColor = (value) => {
  if (value === "transparent") {
    return { h: 0, s: 0, l: 0, a: 0 };
  }
  if ((0, import_predicates.isValidHexString)(value)) {
    return hexStringToHslaColor(value);
  }
  if ((0, import_predicates.isValidHslaString)(value)) {
    return parseHslaString(value);
  }
  if ((0, import_predicates.isValidRgbaString)(value)) {
    return rgbaStringToHslaColor(value);
  }
  return null;
};
const stringToSameTypeColor = (value) => {
  value = value.trim();
  if ((0, import_predicates.isValidHexString)(value)) {
    return value.startsWith("#") ? value : `#${value}`;
  }
  if ((0, import_predicates.isValidRgbaString)(value)) {
    return parseRgbaString(value);
  }
  if ((0, import_predicates.isValidHslaString)(value)) {
    return parseHslaString(value);
  }
  if ((0, import_predicates.isTransparent)(value)) {
    return value;
  }
  return "";
};
const colorToSameTypeString = (color) => {
  if (typeof color === "string" && ((0, import_predicates.isValidHexString)(color) || (0, import_predicates.isTransparent)(color))) {
    return color;
  }
  if ((0, import_predicates.isRGBColor)(color)) {
    return rgbaColorToRgbaString(color);
  }
  if ((0, import_predicates.isHSLColor)(color)) {
    return hslaColorToHslaString(color);
  }
  return "";
};
const hexStringToRgbaColor = (hex) => {
  hex = hex.replace("#", "");
  const r = parseInt(hex.substring(0, 2), 16);
  const g = parseInt(hex.substring(2, 4), 16);
  const b = parseInt(hex.substring(4, 6), 16);
  return { r, g, b };
};
const rgbaColorToRgbaString = (color) => {
  const { a, b, g, r } = color;
  return color.a === 0 ? "transparent" : color.a != void 0 ? `rgba(${r},${g},${b},${a})` : `rgb(${r},${g},${b})`;
};
const hslaColorToHslaString = (color) => {
  const { h, s, l, a } = color;
  const sPerc = Math.round(s * 100);
  const lPerc = Math.round(l * 100);
  return color.a === 0 ? "transparent" : color.a != void 0 ? `hsla(${h},${sPerc}%,${lPerc}%,${a})` : `hsl(${h},${sPerc}%,${lPerc}%)`;
};
const hexStringToHslaColor = (hex) => {
  const rgbaString = colorToSameTypeString(hexStringToRgbaColor(hex));
  return rgbaStringToHslaColor(rgbaString);
};
const rgbaStringToHslaColor = (rgba) => {
  const rgbaColor = parseRgbaString(rgba);
  const r = rgbaColor.r / 255;
  const g = rgbaColor.g / 255;
  const b = rgbaColor.b / 255;
  const max = Math.max(r, g, b), min = Math.min(r, g, b);
  let h, s;
  const l = (max + min) / 2;
  if (max == min) {
    h = s = 0;
  } else {
    const d = max - min;
    s = l >= 0.5 ? d / (2 - (max + min)) : d / (max + min);
    switch (max) {
      case r:
        h = (g - b) / d * 60;
        break;
      case g:
        h = ((b - r) / d + 2) * 60;
        break;
      default:
        h = ((r - g) / d + 4) * 60;
        break;
    }
  }
  const res = { h: Math.round(h), s, l };
  const a = rgbaColor.a;
  if (a != void 0) {
    res.a = a;
  }
  return res;
};
const parseRgbaString = (str) => {
  const [r, g, b, a] = str.replace(CLEAN_RGBA_REGEX, "").split(",").map((c) => Number.parseFloat(c));
  return { r, g, b, a };
};
const parseHslaString = (str) => {
  const [h, s, l, a] = str.replace(CLEAN_HSLA_REGEX, "").split(",").map((c) => Number.parseFloat(c));
  return { h, s: s / 100, l: l / 100, a };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  colorToSameTypeString,
  hexStringToRgbaColor,
  stringToHslaColor,
  stringToSameTypeColor
});
//# sourceMappingURL=cssColorUtils.js.map