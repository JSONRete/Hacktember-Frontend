{"version":3,"sources":["../../../src/hooks/usePagesOrInfinite.ts"],"sourcesContent":["import { useCallback, useMemo, useRef, useState } from 'react';\n\nimport { disableSWRDevtools } from './clerk-swr';\ndisableSWRDevtools();\nimport { useSWR, useSWRInfinite } from './clerk-swr';\nimport type { ValueOrSetter } from './types';\nimport type { PaginatedResources } from './types';\n\nfunction getDifferentKeys(obj1: Record<string, unknown>, obj2: Record<string, unknown>): Record<string, unknown> {\n  const keysSet = new Set(Object.keys(obj2));\n  const differentKeysObject: Record<string, unknown> = {};\n\n  for (const key1 of Object.keys(obj1)) {\n    if (!keysSet.has(key1)) {\n      differentKeysObject[key1] = obj1[key1];\n    }\n  }\n\n  return differentKeysObject;\n}\n\ntype PagesOrInfiniteOptions = {\n  /**\n   * This the starting point for your fetched results. The initial value persists between re-renders\n   */\n  initialPage?: number;\n  /**\n   * Maximum number of items returned per request. The initial value persists between re-renders\n   */\n  pageSize?: number;\n};\n\nexport const useWithSafeValues = <T extends PagesOrInfiniteOptions>(params: T | true | undefined, defaultValues: T) => {\n  const shouldUseDefaults = typeof params === 'boolean' && params;\n\n  // Cache initialPage and initialPageSize until unmount\n  const initialPageRef = useRef(\n    shouldUseDefaults ? defaultValues.initialPage : params?.initialPage ?? defaultValues.initialPage,\n  );\n  const pageSizeRef = useRef(shouldUseDefaults ? defaultValues.pageSize : params?.pageSize ?? defaultValues.pageSize);\n\n  const newObj: Record<string, unknown> = {};\n  for (const key of Object.keys(defaultValues)) {\n    // @ts-ignore\n    newObj[key] = shouldUseDefaults ? defaultValues[key] : params?.[key] ?? defaultValues[key];\n  }\n\n  return {\n    ...newObj,\n    initialPage: initialPageRef.current,\n    pageSize: pageSizeRef.current,\n  } as T;\n};\n\ntype ArrayType<DataArray> = DataArray extends Array<infer ElementType> ? ElementType : never;\ntype ExtractData<Type> = Type extends { data: infer Data } ? ArrayType<Data> : Type;\n\ntype UsePagesOrInfinite = <\n  Params extends PagesOrInfiniteOptions,\n  FetcherReturnData extends Record<string, any>,\n  CacheKeys = Record<string, unknown>,\n>(\n  /**\n   * The parameters will be passed to the fetcher\n   */\n  params: Params,\n  /**\n   * A Promise returning function to fetch your data\n   */\n  fetcher: ((p: Params) => FetcherReturnData | Promise<FetcherReturnData>) | undefined,\n  /**\n   * Internal configuration of the hook\n   */\n  options: {\n    /**\n     * Persists the previous pages with new ones in the same array\n     */\n    infinite?: boolean;\n    /**\n     * Return the previous key's data until the new data has been loaded\n     */\n    keepPreviousData?: boolean;\n    /**\n     * Should a request be triggered\n     */\n    enabled?: boolean;\n  },\n  cacheKeys: CacheKeys,\n) => PaginatedResources<ExtractData<FetcherReturnData>> & {\n  unstable__mutate: () => Promise<unknown>;\n};\n\nexport const usePagesOrInfinite: UsePagesOrInfinite = (params, fetcher, options, cacheKeys) => {\n  const [paginatedPage, setPaginatedPage] = useState(params.initialPage ?? 1);\n\n  // Cache initialPage and initialPageSize until unmount\n  const initialPageRef = useRef(params.initialPage ?? 1);\n  const pageSizeRef = useRef(params.pageSize ?? 10);\n\n  const enabled = options.enabled ?? true;\n  const triggerInfinite = options.infinite ?? false;\n  const keepPreviousData = options.keepPreviousData ?? false;\n\n  const pagesCacheKey = {\n    ...cacheKeys,\n    ...params,\n    initialPage: paginatedPage,\n    pageSize: pageSizeRef.current,\n  };\n\n  const {\n    data: swrData,\n    isValidating: swrIsValidating,\n    isLoading: swrIsLoading,\n    error: swrError,\n    mutate: swrMutate,\n  } = useSWR(\n    !triggerInfinite && !!fetcher && enabled ? pagesCacheKey : null,\n    cacheKeyParams => {\n      // @ts-ignore\n      const requestParams = getDifferentKeys(cacheKeyParams, cacheKeys);\n      // @ts-ignore\n      return fetcher?.(requestParams);\n    },\n    { keepPreviousData },\n  );\n\n  const {\n    data: swrInfiniteData,\n    isLoading: swrInfiniteIsLoading,\n    isValidating: swrInfiniteIsValidating,\n    error: swrInfiniteError,\n    size,\n    setSize,\n    mutate: swrInfiniteMutate,\n  } = useSWRInfinite(\n    pageIndex => {\n      if (!triggerInfinite || !enabled) {\n        return null;\n      }\n\n      return {\n        ...params,\n        ...cacheKeys,\n        initialPage: initialPageRef.current + pageIndex,\n        pageSize: pageSizeRef.current,\n      };\n    },\n    cacheKeyParams => {\n      // @ts-ignore\n      const requestParams = getDifferentKeys(cacheKeyParams, cacheKeys);\n      // @ts-ignore\n      return fetcher?.(requestParams);\n    },\n  );\n\n  const page = useMemo(() => {\n    if (triggerInfinite) {\n      return size;\n    }\n    return paginatedPage;\n  }, [triggerInfinite, size, paginatedPage]);\n\n  const fetchPage: ValueOrSetter<number> = useCallback(\n    numberOrgFn => {\n      if (triggerInfinite) {\n        void setSize(numberOrgFn);\n        return;\n      }\n      return setPaginatedPage(numberOrgFn);\n    },\n    [setSize],\n  );\n\n  const data = useMemo(() => {\n    if (triggerInfinite) {\n      return swrInfiniteData?.map(a => a?.data).flat() ?? [];\n    }\n    return swrData?.data ?? [];\n  }, [triggerInfinite, swrData, swrInfiniteData]);\n\n  const count = useMemo(() => {\n    if (triggerInfinite) {\n      return swrInfiniteData?.[swrInfiniteData?.length - 1]?.total_count || 0;\n    }\n    return swrData?.total_count ?? 0;\n  }, [triggerInfinite, swrData, swrInfiniteData]);\n\n  const isLoading = triggerInfinite ? swrInfiniteIsLoading : swrIsLoading;\n  const isFetching = triggerInfinite ? swrInfiniteIsValidating : swrIsValidating;\n  const isError = !!(triggerInfinite ? swrInfiniteError : swrError);\n  /**\n   * Helpers\n   */\n  const fetchNext = useCallback(() => {\n    fetchPage(n => Math.max(0, n + 1));\n  }, [fetchPage]);\n\n  const fetchPrevious = useCallback(() => {\n    fetchPage(n => Math.max(0, n - 1));\n  }, [fetchPage]);\n\n  const offsetCount = (initialPageRef.current - 1) * pageSizeRef.current;\n\n  const pageCount = Math.ceil((count - offsetCount) / pageSizeRef.current);\n  const hasNextPage = count - offsetCount * pageSizeRef.current > page * pageSizeRef.current;\n  const hasPreviousPage = (page - 1) * pageSizeRef.current > offsetCount * pageSizeRef.current;\n\n  const unstable__mutate = triggerInfinite ? swrInfiniteMutate : swrMutate;\n\n  return {\n    data,\n    count,\n    isLoading,\n    isFetching,\n    isError,\n    page,\n    pageCount,\n    fetchPage,\n    fetchNext,\n    fetchPrevious,\n    hasNextPage,\n    hasPreviousPage,\n    unstable__mutate,\n  };\n};\n"],"mappings":"AAAA,SAAS,aAAa,SAAS,QAAQ,gBAAgB;AAEvD,SAAS,0BAA0B;AACnC,mBAAmB;AACnB,SAAS,QAAQ,sBAAsB;AAIvC,SAAS,iBAAiB,MAA+B,MAAwD;AAC/G,QAAM,UAAU,IAAI,IAAI,OAAO,KAAK,IAAI,CAAC;AACzC,QAAM,sBAA+C,CAAC;AAEtD,aAAW,QAAQ,OAAO,KAAK,IAAI,GAAG;AACpC,QAAI,CAAC,QAAQ,IAAI,IAAI,GAAG;AACtB,0BAAoB,IAAI,IAAI,KAAK,IAAI;AAAA,IACvC;AAAA,EACF;AAEA,SAAO;AACT;AAaO,MAAM,oBAAoB,CAAmC,QAA8B,kBAAqB;AACrH,QAAM,oBAAoB,OAAO,WAAW,aAAa;AAGzD,QAAM,iBAAiB;AAAA,IACrB,oBAAoB,cAAc,cAAc,QAAQ,eAAe,cAAc;AAAA,EACvF;AACA,QAAM,cAAc,OAAO,oBAAoB,cAAc,WAAW,QAAQ,YAAY,cAAc,QAAQ;AAElH,QAAM,SAAkC,CAAC;AACzC,aAAW,OAAO,OAAO,KAAK,aAAa,GAAG;AAE5C,WAAO,GAAG,IAAI,oBAAoB,cAAc,GAAG,IAAI,SAAS,GAAG,KAAK,cAAc,GAAG;AAAA,EAC3F;AAEA,SAAO;AAAA,IACL,GAAG;AAAA,IACH,aAAa,eAAe;AAAA,IAC5B,UAAU,YAAY;AAAA,EACxB;AACF;AAwCO,MAAM,qBAAyC,CAAC,QAAQ,SAAS,SAAS,cAAc;AAC7F,QAAM,CAAC,eAAe,gBAAgB,IAAI,SAAS,OAAO,eAAe,CAAC;AAG1E,QAAM,iBAAiB,OAAO,OAAO,eAAe,CAAC;AACrD,QAAM,cAAc,OAAO,OAAO,YAAY,EAAE;AAEhD,QAAM,UAAU,QAAQ,WAAW;AACnC,QAAM,kBAAkB,QAAQ,YAAY;AAC5C,QAAM,mBAAmB,QAAQ,oBAAoB;AAErD,QAAM,gBAAgB;AAAA,IACpB,GAAG;AAAA,IACH,GAAG;AAAA,IACH,aAAa;AAAA,IACb,UAAU,YAAY;AAAA,EACxB;AAEA,QAAM;AAAA,IACJ,MAAM;AAAA,IACN,cAAc;AAAA,IACd,WAAW;AAAA,IACX,OAAO;AAAA,IACP,QAAQ;AAAA,EACV,IAAI;AAAA,IACF,CAAC,mBAAmB,CAAC,CAAC,WAAW,UAAU,gBAAgB;AAAA,IAC3D,oBAAkB;AAEhB,YAAM,gBAAgB,iBAAiB,gBAAgB,SAAS;AAEhE,aAAO,UAAU,aAAa;AAAA,IAChC;AAAA,IACA,EAAE,iBAAiB;AAAA,EACrB;AAEA,QAAM;AAAA,IACJ,MAAM;AAAA,IACN,WAAW;AAAA,IACX,cAAc;AAAA,IACd,OAAO;AAAA,IACP;AAAA,IACA;AAAA,IACA,QAAQ;AAAA,EACV,IAAI;AAAA,IACF,eAAa;AACX,UAAI,CAAC,mBAAmB,CAAC,SAAS;AAChC,eAAO;AAAA,MACT;AAEA,aAAO;AAAA,QACL,GAAG;AAAA,QACH,GAAG;AAAA,QACH,aAAa,eAAe,UAAU;AAAA,QACtC,UAAU,YAAY;AAAA,MACxB;AAAA,IACF;AAAA,IACA,oBAAkB;AAEhB,YAAM,gBAAgB,iBAAiB,gBAAgB,SAAS;AAEhE,aAAO,UAAU,aAAa;AAAA,IAChC;AAAA,EACF;AAEA,QAAM,OAAO,QAAQ,MAAM;AACzB,QAAI,iBAAiB;AACnB,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT,GAAG,CAAC,iBAAiB,MAAM,aAAa,CAAC;AAEzC,QAAM,YAAmC;AAAA,IACvC,iBAAe;AACb,UAAI,iBAAiB;AACnB,aAAK,QAAQ,WAAW;AACxB;AAAA,MACF;AACA,aAAO,iBAAiB,WAAW;AAAA,IACrC;AAAA,IACA,CAAC,OAAO;AAAA,EACV;AAEA,QAAM,OAAO,QAAQ,MAAM;AACzB,QAAI,iBAAiB;AACnB,aAAO,iBAAiB,IAAI,OAAK,GAAG,IAAI,EAAE,KAAK,KAAK,CAAC;AAAA,IACvD;AACA,WAAO,SAAS,QAAQ,CAAC;AAAA,EAC3B,GAAG,CAAC,iBAAiB,SAAS,eAAe,CAAC;AAE9C,QAAM,QAAQ,QAAQ,MAAM;AAC1B,QAAI,iBAAiB;AACnB,aAAO,kBAAkB,iBAAiB,SAAS,CAAC,GAAG,eAAe;AAAA,IACxE;AACA,WAAO,SAAS,eAAe;AAAA,EACjC,GAAG,CAAC,iBAAiB,SAAS,eAAe,CAAC;AAE9C,QAAM,YAAY,kBAAkB,uBAAuB;AAC3D,QAAM,aAAa,kBAAkB,0BAA0B;AAC/D,QAAM,UAAU,CAAC,EAAE,kBAAkB,mBAAmB;AAIxD,QAAM,YAAY,YAAY,MAAM;AAClC,cAAU,OAAK,KAAK,IAAI,GAAG,IAAI,CAAC,CAAC;AAAA,EACnC,GAAG,CAAC,SAAS,CAAC;AAEd,QAAM,gBAAgB,YAAY,MAAM;AACtC,cAAU,OAAK,KAAK,IAAI,GAAG,IAAI,CAAC,CAAC;AAAA,EACnC,GAAG,CAAC,SAAS,CAAC;AAEd,QAAM,eAAe,eAAe,UAAU,KAAK,YAAY;AAE/D,QAAM,YAAY,KAAK,MAAM,QAAQ,eAAe,YAAY,OAAO;AACvE,QAAM,cAAc,QAAQ,cAAc,YAAY,UAAU,OAAO,YAAY;AACnF,QAAM,mBAAmB,OAAO,KAAK,YAAY,UAAU,cAAc,YAAY;AAErF,QAAM,mBAAmB,kBAAkB,oBAAoB;AAE/D,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;","names":[]}