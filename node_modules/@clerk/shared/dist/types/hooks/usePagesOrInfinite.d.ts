import type { PaginatedResources } from './types';
type PagesOrInfiniteOptions = {
    /**
     * This the starting point for your fetched results. The initial value persists between re-renders
     */
    initialPage?: number;
    /**
     * Maximum number of items returned per request. The initial value persists between re-renders
     */
    pageSize?: number;
};
export declare const useWithSafeValues: <T extends PagesOrInfiniteOptions>(params: true | T | undefined, defaultValues: T) => T;
type ArrayType<DataArray> = DataArray extends Array<infer ElementType> ? ElementType : never;
type ExtractData<Type> = Type extends {
    data: infer Data;
} ? ArrayType<Data> : Type;
type UsePagesOrInfinite = <Params extends PagesOrInfiniteOptions, FetcherReturnData extends Record<string, any>, CacheKeys = Record<string, unknown>>(
/**
 * The parameters will be passed to the fetcher
 */
params: Params, 
/**
 * A Promise returning function to fetch your data
 */
fetcher: ((p: Params) => FetcherReturnData | Promise<FetcherReturnData>) | undefined, 
/**
 * Internal configuration of the hook
 */
options: {
    /**
     * Persists the previous pages with new ones in the same array
     */
    infinite?: boolean;
    /**
     * Return the previous key's data until the new data has been loaded
     */
    keepPreviousData?: boolean;
    /**
     * Should a request be triggered
     */
    enabled?: boolean;
}, cacheKeys: CacheKeys) => PaginatedResources<ExtractData<FetcherReturnData>> & {
    unstable__mutate: () => Promise<unknown>;
};
export declare const usePagesOrInfinite: UsePagesOrInfinite;
export {};
//# sourceMappingURL=usePagesOrInfinite.d.ts.map